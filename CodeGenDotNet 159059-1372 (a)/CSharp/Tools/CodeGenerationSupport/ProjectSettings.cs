// ====================================================================
//  Copyright ©2004, Kathleen Dollard, All Rights Reserved.
// ====================================================================
//   I'm distributing this code so you'll be able to use it to see code
//   generation in action and I hope it will be useful and you'll enjoy 
//   using it. This code is provided "AS IS" without warranty, either 
//   expressed or implied, including implied warranties of merchantability 
//   and/or fitness for a particular purpose. 
// ====================================================================
//  Summary: Currently unused code that could be reused to isolate project settings. This proved to complex for most scenarios in testing.

using System;

namespace KADGen.CodeGenerationSupport
{
	public class ProjectSettings : SettingsBase
	{
		//NOTE: I used get functions rather than readonly properties with 
		//      parameters because I planned to convert this code to C#

		// NOTE: maintaining the project settings was too much trouble for most project. 
		//       you can alter this to provide support for those files again.
		const string localNspaceName = "http://kadgen.com/KADGenProjectSettings.xsd";

		protected internal override System.Xml.XmlNode Node
		{
			get
			{
				return base.Node;
			}
			set
			{
				base.Node = value;
				mNsmgr.AddNamespace( "kp", localNspaceName );
			}
		}

		protected internal string GetNamespacePrefix()
		{
			if( mNode == null )
			{
				return "kp";
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:Namespace", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "Prefix" );
			}
		}

		protected internal string GetCommentStart( string language )
		{
			if( mNode == null )
			{
				// I deliberately left this case sensitive to ease later transition to a project file
				switch( language)
				{
					case "VB":
						return "' ";
					case "CSharp":
						return "/* ";
					case "XML":
						return "<!-- ";
					case "StoredProc":
						return "/* ";
				}
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:CommentCharacters/kp:CharacterSet[@Language='" + language + "']", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "Start" );
			}
			return "";
		}

		protected internal string GetCommentEnd( string language )
		{
			if( mNode == null )
			{
				switch( language )
				{
					case "VB":
						return "";
					case "CSharp":
						return " */ ";
					case "XML":
						return " -->";
					case "StoredProc":
						return " */";
				}
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:CommentCharacters/kp:CharacterSet[@Language='" + language + "']", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "End" );
			}
			return "";
		}

		protected internal string GetCommentText( string genType )
		{
			if( mNode == null )
			{
				switch( genType )
				{
					case "GenOnceMessage":
						return "This file is only generated if missing. Delete the file to force regeneration.";
					case "GenUntilEditedMessage":
						return "This file is regenerated until its edited. Delete to force regeneration.";
					case "GenAlwaysMessage":
						return "This file autogenerated - DO NOT EDIT THIS FILE";
					case "GenNeverMessage":
						return "Add an intelligent message if you figure out a way to use this";
					case "GenOverwriteMessage":
						return "This file will be overwritten – DO NOT EDIT THIS FILE – YOUR EDITS WILL BE LOST";
				}
			}
			else
			{
				System.Xml.XmlNode elem;
				string cultureName = System.Globalization.CultureInfo.CurrentCulture.Name;
				elem = mNode.SelectSingleNode( "kp:Messages/" + genType + "Message", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, cultureName );
			}
			return "";
		}

		protected internal string GetCommentStart( Utility.OutputType language )
		{
			return GetCommentStart( language.ToString() );
		}

		protected internal string GetCommentEnd( Utility.OutputType language )
		{
			return GetCommentEnd( language.ToString() );
		}

		protected internal string GetCommentText( Utility.GenType genType )
		{
			return GetCommentText( genType.ToString() );
		}

		protected internal string GetHashExplanation()
		{
			if( mNode == null )
			{
				return "This funny number is a hash, dont change it";
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:HashSettings", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "HashExplanation" );
			}
		}

		protected internal string GetHashMarker()
		{
			if( mNode == null )
			{
				return "%%%###%%%";
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:HashSettings", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "HashMarker" );
			}
		}

		protected internal string GetHeaderMarker()
		{
			if( mNode == null )
			{
				return "***^^^***|||***^^^***";
			}
			else
			{
				System.Xml.XmlNode elem;
				elem = mNode.SelectSingleNode( "kp:HashSettings", mNsmgr );
				return Utility.Tools.GetAttributeOrEmpty( elem, "HeaderMarker" );
			}
		}
	}
}
